// Copyright Hugh Perkins 2006
// hughperkins@gmail.com http://manageddreams.com
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 as published by the
// Free Software Foundation;
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
//  more details.
//
// You should have received a copy of the GNU General Public License along
// with this program in the file licence.txt; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-
// 1307 USA
// You can find the licence also on the web at:
// http://www.opensource.org/licenses/gpl-license.php
//

using System;
using System.Collections;
using System.Text; // for Encoding
    
namespace OSMP
{
    // sharedkey, spoofing protection
    // ============================
    //
    // sharedkey, int32, is used to make spoofing harder.  No attempt to eliminate man-in-the-middle
    // if the sharedkey on an incoming packet doesnt match that for the connection, it is rejected
    //
    // Protocol for key exchange:
    //   client sends R packet to server.  This requests the server to send it the shared key, and contains a temporary key to authenticate the server reply
    //   server sends A packet to server, which contains the shared key, and also the temporary client key the client sent
    //   client sends K keepalive packet to the server.  Client now considers connection "open"
    //   server receives K keepalive packet and considers connection open
    //
    // what we have achieved is to avoid the client pretending to be someone else, since the client can only find out the sharedkey if it provides
    // a valid return ip address to the server
    // server spoofing is prevented in most cases because it is the client making the request, and because the server has to receive the temporary,
    // client key sent to its address by the client, in order to create a valid A packet
    // we can mitigate this later using an IM (IRC, Jabber...) authentication scheme.
    //
    // The packets are then forwarded to the appropriate packethandler for higher-level processing, such as streaming etc
    // Packet format:
    // [int32 sharedkey][short sequence][char packetcode][data .... ]
    // packetcodes can be registered by specific packethandlers. The following packetcodes are native to the class itself:
    //
    // R   -> request a shared key.  Sent by client to server to request that the server send it the shared key
    //    Packet format:   [int32 xxx][short xxx][char 'R'][temporary client key]
    //
    // C   -> reply by server to R packet.
    //    Packet format:   [int32 xxx][short xxx][char 'C'][temporary client key][shared key]
    //
    // C   -> reply by client to A packet
    //
    // ... where xxx means undefined, can be anything 
    //
    // client only accepts C packets with the correct tempclientkey
    // server replies to any R packet, generating the shared key if the connection didnt exist before
    // client marks connection verified on receipt of A packet
    // server marks connection verified on receipt of any valid non-R packet
    
    // note: separate NetSharedSecretExchange object generated by each NetworkModelConnection
    public class NetSharedSecretExchange
    {
        public int RPacketIntervalSeconds = 1;        
        
        public bool Validated = false;
        public int SharedSecretKey;

        BinaryPacker binarypacker = new BinaryPacker();

        NetworkModelConnection parent;
        bool isserver;
        int tempclientkey;
        bool initialrpacketsent;
        DateTime lastRpacket; // for client
        
        static MyRand rand;
        
        public NetSharedSecretExchange( NetworkModelConnection networkmodelconnection, bool isserver )
        {
            this.parent = networkmodelconnection;
            this.isserver = isserver;
            
            parent.RegisterUnsafePacketHandler( 'R', new PacketHandler( RPacketHandler ) );
            parent.RegisterUnsafePacketHandler( 'C', new PacketHandler( CPacketHandler ) );
            
            if( rand == null )
            {
                rand = new MyRand( (int)System.DateTime.Now.Ticks );
            }
            
            lastRpacket = new DateTime();
            
            if( isserver )
            {
                SharedSecretKey = GenerateSharedKey();
            }
            else
            {
                tempclientkey = rand.GetRandomInt( 0, int.MaxValue - 1 );
                //SendRPacketToServer();
            }
        }
        
        public bool ValidateIncomingPacketKey( int key )
        {
            if( Validated && SharedSecretKey == key )
            {
                return true;
            }
            return false;
        }

        public void RPacketHandler( object source, PacketHandlerArgs e )
        {
            if( isserver )
            {
                byte[] packet = e.Data;
                int tempnextposition = e.NextPosition;
                int tempclientkey = (int)binarypacker.ReadValueFromBuffer( packet, ref tempnextposition, typeof( int ) );

                byte[] newpacket = new byte[8];
                tempnextposition = 0;
                
                Console.WriteLine( "R packet received, sending C packet, tempclientkey: " + tempclientkey.ToString() + " sharedkey: " + SharedSecretKey.ToString() );

                binarypacker.WriteValueToBuffer(newpacket, ref tempnextposition, tempclientkey);
                binarypacker.WriteValueToBuffer(newpacket, ref tempnextposition, SharedSecretKey);
                parent.Send( 'C', newpacket );
            }
        }

        public void CPacketHandler( object source, PacketHandlerArgs e )
        {
            if( !isserver ) // client
            {
                byte[] packet = e.Data;
                int tempnextposition = e.NextPosition;
                int tempclientkey = (int)binarypacker.ReadValueFromBuffer(packet, ref tempnextposition, typeof(int));
                Console.WriteLine( "C packet received, tempclientkey: " + tempclientkey.ToString() );
                if( tempclientkey == this.tempclientkey )
                {
                    SharedSecretKey = (int)binarypacker.ReadValueFromBuffer(packet, ref tempnextposition, typeof(int));
                    Console.WriteLine( "Connection to server confirmed, sharedkey: " + SharedSecretKey.ToString() );
                    Validated = true;
                    parent.Send( 'C', new byte[]{} );
                }
                else
                {
                    Console.WriteLine("WARNING: potential spoof packet detected, allegedly from server " + Encoding.ASCII.GetString( e.Data, 0, e.Data.Length ) );
                }
            }
            else // server
            {
                if( !Validated && e.PacketKey == SharedSecretKey )
                {
                    Validated = true;
                    Console.WriteLine("Shared key confirmed; sending ConnectionValidated event to parent" );
                    parent._ConnectionValidated();
                }                
            }
        }
        
        void SendRPacketToServerIfNecessary()
        {
            if( !isserver )
            {
                if( !Validated )
                {
                    if( (int)DateTime.Now.Subtract( lastRpacket ).TotalMilliseconds > RPacketIntervalSeconds * 1000 || !initialrpacketsent )
                    {
                        SendRPacketToServer();
                    }
                }
            }
        }
        
        void SendRPacketToServer()
        {
            Console.WriteLine( "Sending R packet to server...");
            byte[] packet = new byte[4];
            int tempnextposition = 0;
            binarypacker.WriteValueToBuffer(packet, ref tempnextposition, tempclientkey);
            parent.Send( 'R', packet );
            lastRpacket = DateTime.Now;
            initialrpacketsent = true;
        }
        
        int GenerateSharedKey()
        {
            return rand.GetRandomInt( 0, int.MaxValue - 1 );
        }
        
        public void Tick()
        {
            if( Validated )
            {
                return;
            }
            SendRPacketToServerIfNecessary();
        }
    }
}
